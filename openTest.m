clc; clear all; close all;
import casadi.*

% np = 3;
% T = MX.sym('T',np,1);
% TSum = 0;
% for i = 1 : np
%     TSum = TSum + T(i);
% end
% a = [1,5,1,5]';
% 
% g = {};
% g = {g{:}, T};
% g = {g{:}, T};
% g = {g{:}, T};
% g = {g{:}, a};
% g{:}
% vertcat(g{:})


% ith = SX.sym('ith');
% 
% N = [30;30;30];
% cumuN = [30;60;90];
% 
% 
% F = Function('F', {T}, {T > 0})
% F([0.1;0.1;0.1])
% abs(sum(T))
% 
% R1 = MX.sym('R1',3,3);
% R2 = MX.sym('R2',3,3);
% R1*R2
% R3 = SX.sym('R3',3,3);
% R4 = SX.sym('R4',3,3);
% R3*R4
% E = trace(R4)

% A = [1,2,3;
%      4,5,6;
%      7,8,9];
% res1 = A*A*A;
% disp(res1);
% res2 = A^3;
% disp(res2);

% x = SX.sym('x');
% y = SX.sym('y');
% f_true = Function('f_true',{x,y},{cos(x)+y});
% f_false = Function('f_false',{x,y},{sin(x)+y});
% f_cond = Function.if_else('f_cond', f_true, f_false);
% disp(f_cond);
% f_cond(1,x,y)

% theta = acos((R.trace()-1)/2 );
% skw = (R-transpose(R))/2/sin(theta);
% w = skw.inv_skew(); % is a unit vector
% skew(w*theta)

% v1 = MX.sym('v1',3,1);
% v2 = MX.sym('v2',3,1);
% cross(v1, v2)
% v1.cross(v2)
% v1.*0.5
% 
% v3 = SX.sym('v3',3,1);
% v4 = SX.sym('v4',3,1);
% c = SX.sym('c');
% sg = v3.*c
% cross(v3, v4)
% A = v3.cross(v4)
% B = v3.*0.5
% C = sum(v3)
% D = transpose(v4)

% isvec(v,3)
% skew(v)

% R = SX.sym('R',3,3);
% 
% theta = acos((trace(R)-1)/2);
% f_true = Function('f_true',{R}, ...
%     {zeros(3,3)});
% f_false = Function('f_false',{R}, ...
%     {(R-transpose(R)).*(theta/(2*sin(theta)))});
% f_cond = Function.if_else('f_cond', f_true, f_false);
% skw1 = f_cond(theta==0, R);
% skw2 = f_cond(theta==0, [1,2,3;4,5,6;7,8,9]);
% disp(skw1);
% disp(skw2);
% k = 1;
% R_k = SX.sym('R_k',3,3);
% R_ref = [1,2,3;
%          4,5,6;
%          7,8,9];
% 
% 
% R_arg = SX.sym('R_test',3,3);
% log_map_k = Function.if_else(['log_map_k' num2str(k)], ...
%     Function(['f_true_k' num2str(k)],{R_arg}, {zeros(3,3)}), ...
%     Function(['f_false_k' num2str(k)],{R_arg}, ...
%     {(R_arg-transpose(R_arg)).*(acos((trace(R_arg)-1)/2)/(2*sin(acos((trace(R_arg)-1)/2))))}));
% % Rtmp_k = transpose(R_ref)*R_k;
% theta1 = 0;
% Rtmp_k1 = [cos(deg2rad(theta1)), -sin(deg2rad(theta1)), 0;
%           sin(deg2rad(theta1)), cos(deg2rad(theta1)), 0;
%           0,  0,  1];
% theta2 = 15+2000000000*eps;
% Rtmp_k2 = [cos(deg2rad(theta2)), -sin(deg2rad(theta2)), 0;
%           sin(deg2rad(theta2)), cos(deg2rad(theta2)), 0;
%           0,  0,  1];
% Rtmp_k = transpose(Rtmp_k1)*R_k;
% e_R_k = vex(log_map_k(acos((trace(Rtmp_k)-1)/2)==0, Rtmp_k))
% SO3.rand().R()

% f = Function('f',{R_arg},...
%            {e_R_k});
% disp(f)
% f(R_ref)

% v = [3,51,6,7];
% s = length(v);
% currentIndex = 1;
% a = currentIndex;
% b = currentIndex + s - 1;

% r = [1,2,3,4,5,6,7,8,9];
% R = transpose(reshape(r,3,3));

e_index = SX.sym('index');

x = SX.sym('x',3,1);

v = [printme(transpose(x.^2),0);printme(transpose(x.^3),1)];
v_cell = vertsplit(v);

default = 0;
c = conditional(e_index,v_cell,default,false);


% Test 

f = Function('f',{e_index,x},{c});

f(0,[3;3;3]) % 3^2

% f = LogMap('f',1);
% res = f(0);
% disp(res);
% 
% x = SX.sym('x');
% disp(f(x));

% f(1,[3;3;3]) % 3^3
% f(0.5,[3;3;3]) % default
% f(-1,[3;3;3]) % default
% f(2,[3;3;3]) % default

% % Test
% log_map_k = Function('log_map_k',{index,R_arg},{c});
% 
% theta1 = 0;
% Rtmp_k1 = [cos(deg2rad(theta1)), -sin(deg2rad(theta1)), 0;
%           sin(deg2rad(theta1)), cos(deg2rad(theta1)), 0;
%           0,  0,  1];
% theta2 = 15;
% Rtmp_k2 = [cos(deg2rad(theta2)), -sin(deg2rad(theta2)), 0;
%           sin(deg2rad(theta2)), cos(deg2rad(theta2)), 0;
%           0,  0,  1];
% Rtmp_k = transpose(Rtmp_k1)*Rtmp_k2;
% log_map_k(acos((trace(Rtmp_k)-1)/2)==0, Rtmp_k)
% e_R_k = vex(log_map_k(acos((trace(Rtmp_k)-1)/2)==0, Rtmp_k))
% Nc = 20;

% % Start with an empty NLP
% global w lbw ubw w0 g lbg ubg
% w = {};
% w0 = {};
% lbw = {};
% ubw = {};
% J = 0;
% g = {};
% lbg = {};
% ubg = {};
% 
% global p_body_idx dp_body_idx p_feet_idx Omega_idx DOmega_idx R_idx ...
% F_idx T_idx currentIndex
% p_body_idx = {};
% dp_body_idx = {};
% p_feet_idx = {};
% Omega_idx = {};
% DOmega_idx = {};
% R_idx = {};
% F_idx = {};
% T_idx = {};
% currentIndex = 1;
% 
% R_arg = SX.sym('R_arg',3,3);
% log_map = Function('log_map', {R_arg}, ...
%     {vex(R_arg-transpose(R_arg)).*((1/2) + ...
%     (1/12)*((acos((trace(R_arg)-1)/2))^2) + ...
%     (7/720)*((acos((trace(R_arg)-1)/2))^4))});
% 
% R0 = eul2rotm([deg2rad(-0.2),deg2rad(0.1),deg2rad(-5)], 'XYZ');
% Rf = eul2rotm([deg2rad(0),deg2rad(0),deg2rad(15)], 'XYZ');
% R_ref = zeros(3,3,Nc);
% R0SO3 = SO3(R0);
% RfSO3 = SO3(Rf);
% R = {};
% for i = 1 : Nc
%     R0SO3.interp(RfSO3, i/Nc);
%     R_ref(:,:,i) = R0SO3.interp(RfSO3, i/Nc);
%     R = {R{:}, SX.sym(['R_k' num2str(k)],3,3)};
% end
% 
% R_err_k = transpose(R_ref)*R_k;
% e_R_k = log_map(R_err_k);
% for k = 1 : Nc
%     if k ~= 1
%         addDesignConstraintsAndInit(R_k.reshape(9,1), ...
%                 ones(9,1).*(-1.05), ones(9,1).*(1.05), ...
%                 reshape(SO3.rand().R(),9,1), 'R');
%     end
%     R_k = R{1,k};
% end
% 
% 
% 
% function optDesignVars = unpackIndices(w_opt, designIndices, s1, s2, split)
%     n = length(designIndices);
%     if split == false
%         optDesignVars = zeros(s1,s2,n);
%         for i = 1 : n
%             optDesignVars(:,:,i) = ...
%             reshape(w_opt(vertcat(designIndices{i}),1),s1,s2);
%         end
%     else
%         optDesignVars = zeros(s1,s2,floor(n/s2));
%         for i = 1 : floor(n/s2)
%             for j = 1 : s2
%                 tmp = designIndices(i:i+s2-1);
%                 optDesignVars(:,j,i) = reshape(w_opt(vertcat( ...
%                     tmp{j}),1),s1,1);
%             end
%         end
%     end
% end
% 
% function addGeneralConstraints(g_k, lbg_k, ubg_k)
%     global g lbg ubg
%     if size(g_k,2) > 1 || size(lbg_k,2) > 1 || size(ubg_k,2) > 1
%         disp("Invalid size of constraints. The constraints are one " + ...
%             "column vector.");
%     else
%         if all(size(g_k) == size(lbg_k)) && all(size(g_k) == ...
%                 size(ubg_k)) && all(size(lbg_k) == size(ubg_k))
%             g = {g{:}, g_k};
%             lbg = {lbg{:}, lbg_k};
%             ubg = {ubg{:}, ubg_k};
%         else
%             disp("Invalid size of constraints. The number of upper " + ...
%                 "and lower bound constraints should match the size of g.");
%         end
%     end
% end
% 
% function addDesignConstraintsAndInit(w_k, lbw_k, ubw_k, w0_k, field)
%     global w lbw ubw w0 p_body_idx dp_body_idx p_feet_idx Omega_idx ...
%     DOmega_idx R_idx F_idx T_idx currentIndex
%     if size(w_k,2) > 1 || size(lbw_k,2) > 1 || size(ubw_k,2) > 1 || ...
%             size(w0_k,2) > 1
%         disp("Invalid size of constraints. The constraints are one " + ...
%             "column vector.");
%     else
%         if all(size(w_k) == size(lbw_k)) && all(size(w_k) == ...
%                 size(ubw_k)) && all(size(lbw_k) == size(ubw_k)) && ...
%                 all(size(w_k) == size(w0_k))
%             n = size(w_k);
%             w = {w{:}, w_k};
%             lbw = {lbw{:}, lbw_k};
%             ubw = {ubw{:}, ubw_k};
%             w0 = {w0{:}, w0_k};
%             a = currentIndex;
%             b = currentIndex + n-1;
%             switch (field)
%                 case 'p_body'
%                     p_body_idx = {p_body_idx{:}, a : b};
%                 case 'dp_body'
%                     dp_body_idx = {dp_body_idx{:}, a : b};
%                 case 'p_feet'
%                     p_feet_idx = {p_feet_idx{:}, a : b};
%                 case 'Omega'
%                     Omega_idx = {Omega_idx{:}, a : b};
%                 case 'DOmega'
%                     DOmega_idx = {DOmega_idx{:}, a : b};
%                 case 'R'
%                     R_idx = {R_idx{:}, a : b};
%                 case 'F'
%                     F_idx = {F_idx{:}, a : b};
%                 case 'T'
%                     T_idx = {T_idx{:}, a : b};
%             end
%             currentIndex = b+1;
%         else
%             disp("Invalid size of constraints. The number of upper " + ...
%                 "and lower bound constraints should match the size of w.");
%         end
%     end
% end
